#' Create file that distinguishes between regions and rural areas
#'
#'
#' @description
#' `create_regions` evaluates which regions that each county belongs to, then uses `rural_overlay` to pinpoint
#' rural tracts.  `rural_overlay` merges block centers with the rural_shapefile, and classifies the population of
#' any block with its centroid inside the rural shapefile as rural. It then collapses to tract level, and any tract
#' with over 50 percent population rural is classified as "Rural Areas."  `rural_overlay` is executed within the
#' `create_regions` function, and is separated for testing convenience only. For creating data, only `create_regions`
#' is necessary to run.
#'
#'
#' @param year designates the map year's filepaths
#' @param write write the intermediate file
#' @param create_overlay allows for running only the sp::over function separately to reduce debugging time. To use, first
#' assign location_overlay(create_overlay = T) to a variable, then use location_overlay(create_overlay = variable) to run the
#' rest of the function.
#' @param block_points block centroids generated by `read_block_centers`.
#' @param rural_overlay rural shapefile.
#' @param collapse aggregates blocks into tract and assigns tracts to rural or urban
#'   designation. Setting this to FALSE allows the user to view the block-level designation.
#'
#'
#' @return a data frame
#'
#'
#' @examples
#' create_regions(write = T) # computes and writes the region designations file to the intermediate directory
#'
#'
#' @source shape_CA_tract created using tigris package: /data-raw/R/generate_census_shapes.R
#' @source list of TCAC rural counties: https://www.treasurer.ca.gov/ctcac/Cover-memo.pdf
#'


#' @export
create_regions <- function(year = current_year, write = FALSE,read = !write, testing_handle=FALSE){
  if(read){
    regions <- readr::read_csv(paste0("data/intermediate/", year, "/tract_county_region.csv"),
    col_types = readr::cols(), guess_max = 10000)

    return(regions)
  }
  filepaths(year = year)
  #read in tracts and keep county names
  counties <- shape_CA_tract %>% st_drop_geometry()
  counties$county_name <- paste(counties$county_name, 'CA')
  #region to county crosswalk; merge with tracts
  region_xwalk <- read_zip(county_region_xwalk, year, col_types = readr::cols())
  region_xwalk$county <- paste(region_xwalk$county, 'CA')
  counties <- dplyr::left_join(counties, region_xwalk, by = c('county_name' = 'county'))

  #read in USDA rural areas
  shape_rural <- shape_rural(year = year)

  shape_block_centers <- read_block_centers(as_shape = TRUE)

  #create rural overlay in a separate step; saves time if testing:
  rural_overlay <- rural_overlay(shape_block_centers, shape_rural,
    create_overlay = TRUE, collapse = T)
  rural_tract_designation <- rural_overlay(shape_block_centers, create_overlay = rural_overlay)

  region_tract_designation <- dplyr::full_join(counties, rural_tract_designation, by =
                                                  c('fips', 'county_name' = 'cntyname'))
  region_tract_designation$region[which(region_tract_designation$rural_flag == 1)] <-  'Rural Areas'

  # manually add counties designated as rural in methodology
  rural_counties <- c('Alpine', 'Amador', 'Calaveras', 'Colusa', 'Del Norte',
    'Glenn', 'Humboldt', 'Inyo', 'Lake', 'Lassen', 'Mariposa', 'Mendocino',
    'Modoc', 'Mono', 'Nevada', 'Plumas', 'Sierra', 'Siskiyou', 'Tehama', 'Trinity',
    'Tuolumne', 'Butte', 'Shasta', 'Sutter', 'Yuba')
  rural_counties <- paste(rural_counties, 'CA')

  if(testing_handle==TRUE){
    return(rural_counties)
  }

  region_tract_designation$region[which(
    region_tract_designation$county_name %in% rural_counties)] <- "Rural Areas"
  region_tract_designation$rural_flag[which(region_tract_designation$region == 'Rural Areas')] <- 1

  if(write == TRUE){
  readr::write_csv(region_tract_designation, paste0("data/intermediate/", year, "/tract_county_region.csv"))
  }
  else region_tract_designation
}


#' @export
#' @rdname create_regions
rural_overlay <- function(block_points, rural_area, create_overlay = NULL, year = current_year,
                          collapse = TRUE){

  overlay <- create_overlay
  # evaluate block_points
  if(isTRUE(create_overlay) | is.null(overlay)){
    overlay <- sf::st_contains(x = rural_area, y = block_points, sparse = F)
    overlay <- as.vector(overlay)
  }
  #generating the overlay as output if create_overlay == TRUE
  if(isTRUE(create_overlay)) {
    output <- overlay
    collapse = FALSE
  }
  if(year >= 2019 & isTRUE(create_overlay) == FALSE){
    #convert overlay result to dataframe and mark as rural
    matching_points <- as.data.frame(block_points[overlay,])
    matching_points <- dplyr::mutate(matching_points, rural_flag = 1) %>%
      dplyr::select(-geometry)

    # rejoins the rural blocks with the rest
    post_matching <- suppressMessages(
      dplyr::left_join(as.data.frame(block_points), matching_points))

    post_matching[is.na(post_matching)] <- 0
    output <- as.data.frame(post_matching) %>% dplyr::select(-geometry)
  }
  if(collapse != FALSE & !isTRUE(create_overlay)) {
    #sum each tract rural and non-rural population
    post_matching <- dplyr::group_by(post_matching, fips, rural_flag, cntyname)
    post_matching <- dplyr::summarize(post_matching, rural_pct = sum(block_pop_pct*rural_flag),
                                      population = sum(pop20))

    #collapsing to tract
    post_matching <- dplyr::group_by(post_matching, fips, cntyname)
    post_matching <- dplyr::summarize(post_matching, rural_pct = sum(rural_pct),
                                      population = sum(population))

    #adding back in the rural binary
    post_matching <- dplyr::mutate(post_matching, rural_pop = rural_pct * population,
                                   rural_flag = as.integer(rural_pct >= 0.5))
    post_matching[is.na(post_matching) | is.infinite(post_matching$rural_pct)] <- 0
    output <- post_matching
  }

  output
}
